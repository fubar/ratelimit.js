// Generated by CoffeeScript 1.12.7
var EvalSha, RateLimit, _, async, fs, path,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

EvalSha = require('redis-evalsha');

_ = require('underscore');

async = require('async');

module.exports = RateLimit = (function() {
  RateLimit.DEFAULT_PREFIX = 'ratelimit';

  RateLimit.DENIED_NUMS = [1, 2];

  function RateLimit(redisClient, rules, options) {
    var base, base1;
    this.redisClient = redisClient;
    this.options = options != null ? options : {};
    if (_.isString(this.options)) {
      this.options = {
        prefix: this.options
      };
    }
    if ((base = this.options).prefix == null) {
      base.prefix = this.constructor.DEFAULT_PREFIX;
    }
    if ((base1 = this.options).clientPrefix == null) {
      base1.clientPrefix = false;
    }
    this.checkFn = 'check_rate_limit';
    this.checkIncrFn = 'check_incr_rate_limit';
    this["eval"] = new EvalSha(this.redisClient);
    this["eval"].add(this.checkFn, this.checkLimitScript());
    this["eval"].add(this.checkIncrFn, this.checkLimitIncrScript());
    this.rules = this.convertRules(rules);
  }

  RateLimit.prototype.readLua = function(scriptname) {
    switch(scriptname) {
      case 'check_incr_limit':
        return `
-- Credit: http://www.dr-josiah.com/2014/11/introduction-to-rate-limiting-with_26.html

-- there is enough resources, update the counts
for i, limit in ipairs(limits) do
    local saved = saved_keys[i]

    for j, key in ipairs(KEYS) do
        -- update the current timestamp, count, and bucket count
        redis.call('HSET', key, saved.ts_key, saved.trim_before)
        redis.call('HINCRBY', key, saved.count_key, weight)
        redis.call('HINCRBY', key, saved.count_key .. saved.block_id, weight)
    end
end

-- We calculated the longest-duration limit so we can EXPIRE
-- the whole HASH for quick and easy idle-time cleanup :)
if longest_duration > 0 then
    for _, key in ipairs(KEYS) do
        redis.call('EXPIRE', key, longest_duration)
    end
end

return 0
`;
      case 'check_limit':
        return `
-- Credit: http://www.dr-josiah.com/2014/11/introduction-to-rate-limiting-with_26.html

-- handle cleanup and limit checks
for i, limit in ipairs(limits) do
    local duration = limit[1]
    longest_duration = math.max(longest_duration, duration)

    local precision = limit[3] or duration
    precision = math.min(precision, duration)

    local blocks = math.ceil(duration / precision)
    local saved = {}

    table.insert(saved_keys, saved)
    saved.block_id = math.floor(now / precision)
    saved.trim_before = saved.block_id - blocks + 1
    saved.count_key = duration .. ':' .. precision .. ':'
    saved.ts_key = saved.count_key .. 'o'

    for j, key in ipairs(KEYS) do

        local old_ts = redis.call('HGET', key, saved.ts_key)
        old_ts = old_ts and tonumber(old_ts) or saved.trim_before
        if old_ts > now then
            -- don't write in the past
            return 1
        end

        -- discover what needs to be cleaned up
        local decr = 0
        local dele = {}
        local trim = math.min(saved.trim_before, old_ts + blocks)
        for old_block = old_ts, trim - 1 do
            local bkey = saved.count_key .. old_block
            local bcount = redis.call('HGET', key, bkey)
            if bcount then
                decr = decr + tonumber(bcount)
                table.insert(dele, bkey)
            end
        end

        -- handle cleanup
        local cur
        if #dele > 0 then
            redis.call('HDEL', key, unpack(dele))
            cur = redis.call('HINCRBY', key, saved.count_key, -decr)
        else
            cur = redis.call('HGET', key, saved.count_key)
        end

        -- check our limits
        if tonumber(cur or '0') + weight > limit[2] then
            return 1
        end
    end
end
`;
      case 'check_whitelist_blacklist':
        return `
-- Check the whitelist and blacklist sets for the given key
for _, key in ipairs(KEYS) do
    local is_set_member = redis.call('SISMEMBER', whitelist_key, key)
    if tonumber(is_set_member) > 0 then
        return 0
    end

    is_set_member = redis.call('SISMEMBER', blacklist_key, key)
    if tonumber(is_set_member) > 0 then
        return 2
    end
end
`;
      case 'unpack_args':
        return `
-- Credit: http://www.dr-josiah.com/2014/11/introduction-to-rate-limiting-with_26.html
local limits = cjson.decode(ARGV[1])
local now = tonumber(ARGV[2])
local weight = tonumber(ARGV[3] or '1')
local longest_duration = limits[1][1] or 0
local saved_keys = {}

-- Locals for whitelist and blacklist ops
local whitelist_key = ARGV[4] or 'whitelist'
local blacklist_key = ARGV[5] or 'blacklist'
`;
    }
  };

  RateLimit.prototype.checkLimitScript = function() {
    return [this.readLua('unpack_args'), this.readLua('check_whitelist_blacklist'), this.readLua('check_limit'), 'return 0'].join('\n');
  };

  RateLimit.prototype.checkLimitIncrScript = function() {
    return [this.readLua('unpack_args'), this.readLua('check_whitelist_blacklist'), this.readLua('check_limit'), this.readLua('check_incr_limit')].join('\n');
  };

  RateLimit.prototype.convertRules = function(rules) {
    var i, interval, len, limit, precision, ref, results1;
    results1 = [];
    for (i = 0, len = rules.length; i < len; i++) {
      ref = rules[i], interval = ref.interval, limit = ref.limit, precision = ref.precision;
      if (interval && limit) {
        results1.push(_.compact([interval, limit, precision]));
      }
    }
    return results1;
  };

  RateLimit.prototype.prefixKey = function(key, force) {
    var parts;
    if (force == null) {
      force = false;
    }
    parts = [key];
    if (force || !this.options.clientPrefix) {
      parts.unshift(this.options.prefix);
    }
    return _.compact(parts).join(':');
  };

  RateLimit.prototype.whitelistKey = function() {
    return this.prefixKey('whitelist', true);
  };

  RateLimit.prototype.blacklistKey = function() {
    return this.prefixKey('blacklist', true);
  };

  RateLimit.prototype.scriptArgs = function(keys, weight) {
    var adjustedKeys, rules, ts;
    if (weight == null) {
      weight = 1;
    }
    adjustedKeys = _.chain([keys]).flatten().compact().filter(function(key) {
      return _.isString(key) && key.length;
    }).map((function(_this) {
      return function(key) {
        return _this.prefixKey(key);
      };
    })(this)).value();
    if (!adjustedKeys.length) {
      throw new Error("Bad keys: " + keys);
    }
    rules = JSON.stringify(this.rules);
    ts = Math.floor(Date.now() / 1000);
    weight = Math.max(weight, 1);
    return [adjustedKeys, [rules, ts, weight, this.whitelistKey(), this.blacklistKey()]];
  };

  RateLimit.prototype.check = function(keys, callback) {
    var args, err, ref;
    try {
      ref = this.scriptArgs(keys), keys = ref[0], args = ref[1];
    } catch (error) {
      err = error;
      return callback(err);
    }
    return this["eval"].exec(this.checkFn, keys, args, (function(_this) {
      return function(err, result) {
        return callback(err, indexOf.call(_this.constructor.DENIED_NUMS, result) >= 0);
      };
    })(this));
  };

  RateLimit.prototype.incr = function(keys, weight, callback) {
    var args, err, ref, ref1;
    if (arguments.length === 2) {
      ref = [1, weight], weight = ref[0], callback = ref[1];
    }
    try {
      ref1 = this.scriptArgs(keys, weight), keys = ref1[0], args = ref1[1];
    } catch (error) {
      err = error;
      return callback(err);
    }
    return this["eval"].exec(this.checkIncrFn, keys, args, (function(_this) {
      return function(err, result) {
        return callback(err, indexOf.call(_this.constructor.DENIED_NUMS, result) >= 0);
      };
    })(this));
  };

  RateLimit.prototype.keys = function(callback) {
    return this.redisClient.keys(this.prefixKey('*'), (function(_this) {
      return function(err, results) {
        var key, keys, re;
        if (err) {
          return callback(err);
        }
        re = new RegExp(_this.prefixKey('(.+)'));
        keys = (function() {
          var i, len, results1;
          results1 = [];
          for (i = 0, len = results.length; i < len; i++) {
            key = results[i];
            results1.push(re.exec(key)[1]);
          }
          return results1;
        })();
        return callback(null, keys);
      };
    })(this));
  };

  RateLimit.prototype.violatedRules = function(keys, callback) {
    var checkKey;
    checkKey = (function(_this) {
      return function(key, callback) {
        var checkRule;
        checkRule = function(rule, callback) {
          var countKey, interval, limit, precision;
          interval = rule[0], limit = rule[1], precision = rule[2];
          precision = Math.min(precision != null ? precision : interval, interval);
          countKey = interval + ":" + precision + ":";
          return _this.redisClient.hget(_this.prefixKey(key), countKey, function(err, count) {
            if (count == null) {
              count = -1;
            }
            if (!(count >= limit)) {
              return callback();
            }
            return callback(null, {
              interval: interval,
              limit: limit
            });
          });
        };
        return async.map(_this.rules, checkRule, function(err, violatedRules) {
          return callback(err, _.compact(violatedRules));
        });
      };
    })(this);
    return async.concat(_.flatten([keys]), checkKey, callback);
  };

  RateLimit.prototype.limitedKeys = function(callback) {
    return this.keys((function(_this) {
      return function(err, keys) {
        var fn;
        if (err) {
          return callback(err);
        }
        fn = function(key, callback) {
          return _this.check(key, function(err, limited) {
            return callback(limited);
          });
        };
        return async.filter(keys, fn, function(results) {
          return callback(null, results);
        });
      };
    })(this));
  };

  RateLimit.prototype.whitelist = function(keys, callback) {
    var whitelist;
    whitelist = (function(_this) {
      return function(key, callback) {
        key = _this.prefixKey(key);
        return async.series([
          function(callback) {
            return _this.redisClient.srem(_this.blacklistKey(), key, callback);
          }, function(callback) {
            return _this.redisClient.sadd(_this.whitelistKey(), key, callback);
          }
        ], callback);
      };
    })(this);
    return async.each(keys, whitelist, callback);
  };

  RateLimit.prototype.unwhitelist = function(keys, callback) {
    var unwhitelist;
    unwhitelist = (function(_this) {
      return function(key, callback) {
        key = _this.prefixKey(key);
        return _this.redisClient.srem(_this.whitelistKey(), key, callback);
      };
    })(this);
    return async.each(keys, unwhitelist, callback);
  };

  RateLimit.prototype.blacklist = function(keys, callback) {
    var blacklist;
    blacklist = (function(_this) {
      return function(key, callback) {
        key = _this.prefixKey(key);
        return async.series([
          function(callback) {
            return _this.redisClient.srem(_this.whitelistKey(), key, callback);
          }, function(callback) {
            return _this.redisClient.sadd(_this.blacklistKey(), key, callback);
          }
        ], callback);
      };
    })(this);
    return async.each(keys, blacklist, callback);
  };

  RateLimit.prototype.unblacklist = function(keys, callback) {
    var unblacklist;
    unblacklist = (function(_this) {
      return function(key, callback) {
        key = _this.prefixKey(key);
        return _this.redisClient.srem(_this.blacklistKey(), key, callback);
      };
    })(this);
    return async.each(keys, unblacklist, callback);
  };

  return RateLimit;

})();
